function setDefaultAttr(key,name,l){
  Object.defineProperty(key, "length", {
    "value": l
  });
  Object.defineProperty(key, "toString", {
      "value": () => `function ${name}() { [native code] }`
  });

  Object.defineProperty(key, "name", {
      "value": name
  });
}
function newObject(name,value){
  let ob=Object.create(name.prototype,{})
  for (let i in value){
    Object.defineProperty(ob,i,{
      get:()=>value[i],
    })
  }
  return ob
}
function newArray(name,value){
  let ob=Object.create(name.prototype,{})
  for (let i in value){
    ob[i]=value
  }
  return ob
}
function shuffle(arr) {
  let m = arr.length;
  while (m > 1){
      let index = Math.floor(Math.random() * m--);
      [arr[m] , arr[index]] = [arr[index] , arr[m]]
  }
  return arr;
}
function changeCanvasMain(){
    var inject = function () {
    function random(list) {
        let min = 0;
        let max = list.length
        return list[Math.floor(Math.random() * (max - min)) + min];
    }
    let rsalt = random([...Array(7).keys()].map(a => a - 3))
    let gsalt = random([...Array(7).keys()].map(a => a - 3))
    let bsalt = random([...Array(7).keys()].map(a => a - 3))
    let asalt = random([...Array(7).keys()].map(a => a - 3))
    
    const rawGetImageData = CanvasRenderingContext2D.prototype.getImageData;
    
    let noisify = function (canvas, context) {
        if (!context){
          return
        }
        let ctxIdx = ctxArr.indexOf(context);
        let info = ctxInf[ctxIdx];
        const width = canvas.width, height = canvas.height;
        const imageData = rawGetImageData.apply(context, [0, 0, width, height]);
        if (info.useArc || info.useFillText) {
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const n = ((i * (width * 4)) + (j * 4));
                    imageData.data[n + 0] = imageData.data[n + 0] + rsalt;
                    imageData.data[n + 1] = imageData.data[n + 1] + gsalt;
                    imageData.data[n + 2] = imageData.data[n + 2] + bsalt;
                    imageData.data[n + 3] = imageData.data[n + 3] + asalt;
                }
            }
        }
        context.putImageData(imageData, 0, 0);
    };
    
    let ctxArr = [];
    let ctxInf = [];
    
    (function mockGetContext() {
        let rawGetContext = HTMLCanvasElement.prototype.getContext
    
        Object.defineProperty(HTMLCanvasElement.prototype, "getContext", {
            "value": function () {
                let result = rawGetContext.apply(this, arguments);
                if (arguments[0] === '2d' && result) {
                    ctxArr.push(result)
                    ctxInf.push({})
                }
                return result;
            }
        });
        setDefaultAttr(HTMLCanvasElement.prototype.constructor,"getContext",1)
    })();
    
    (function mockArc() {
        let rawArc = CanvasRenderingContext2D.prototype.arc
        Object.defineProperty(CanvasRenderingContext2D.prototype, "arc", {
            "value": function () {
                let ctxIdx = ctxArr.indexOf(this);
                ctxInf[ctxIdx].useArc = true;
                return rawArc.apply(this, arguments);
            }
        });
        setDefaultAttr(CanvasRenderingContext2D.prototype.arc,"arc",5)
  
    })();
    
    (function mockFillText() {
        const rawFillText = CanvasRenderingContext2D.prototype.fillText;
        Object.defineProperty(CanvasRenderingContext2D.prototype, "fillText", {
            "value": function () {
                let ctxIdx = ctxArr.indexOf(this);
                ctxInf[ctxIdx].useFillText = true;
                return rawFillText.apply(this, arguments);
            }
        });
        setDefaultAttr(CanvasRenderingContext2D.prototype.fillText,"fillText",3)
    })();
    
    
    (function mockToBlob() {
        const toBlob = HTMLCanvasElement.prototype.toBlob;
    
        Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
            "value": function () {
                noisify(this, this.getContext("2d"));
                return toBlob.apply(this, arguments);
            }
        });
        setDefaultAttr(HTMLCanvasElement.prototype.toBlob,"toBlob",1)
    })();
    
    (function mockToDataURL() {
        const toDataURL = HTMLCanvasElement.prototype.toDataURL;
        Object.defineProperty(HTMLCanvasElement.prototype, "toDataURL", {
            "value": function () {
                noisify(this, this.getContext("2d"));
                return toDataURL.apply(this, arguments);
            }
        });
        setDefaultAttr(HTMLCanvasElement.prototype.toDataURL,"toDataURL",0)
    })();
    (function mockGetImageData() {
        Object.defineProperty(CanvasRenderingContext2D.prototype, "getImageData", {
            "value": function () {
                noisify(this.canvas, this);
                return rawGetImageData.apply(this, arguments);
            }
        });
        setDefaultAttr(CanvasRenderingContext2D.prototype.getImageData,"getImageData",4)
    })();
    }
    inject()
}
function changeWebGlMain() {
  var inject = function () {
    var config = {
      "random": {
        "value": function () {
          return Math.random();
        },
        "item": function (e) {
          var rand = e.length * config.random.value();
          return e[Math.floor(rand)];
        },
        "number": function (power) {
          var tmp = [];
          for (var i = 0; i < power.length; i++) {
            tmp.push(Math.pow(2, power[i]));
          }
          /*  */
          return config.random.item(tmp);
        },
        "int": function (power) {
          var tmp = [];
          for (var i = 0; i < power.length; i++) {
            var n = Math.pow(2, power[i]);
            tmp.push(new Int32Array([n, n]));
          }
          /*  */
          return config.random.item(tmp);
        },
        "float": function (power) {
          var tmp = [];
          for (var i = 0; i < power.length; i++) {
            var n = Math.pow(2, power[i]);
            tmp.push(new Float32Array([1, n]));
          }
          /*  */
          return config.random.item(tmp);
        }
      },
      "spoof": {
        "webgl": {
          "buffer": function (target) {
            var proto = target.prototype ? target.prototype : target.__proto__;
            const bufferData = proto.bufferData;
            Object.defineProperty(proto, "bufferData", {
              "value": function () {
                var index = Math.floor(config.random.value() * arguments[1].length);
                var noise = arguments[1][index] !== undefined ? 0.1 * config.random.value() * arguments[1][index] : 0;
                //
                arguments[1][index] = arguments[1][index] + noise;
                // window.top.postMessage("webgl-fingerprint-defender-alert", '*');
                //
                return bufferData.apply(this, arguments);
              }
            });
          },
          "parameter": function (target) {
            var proto = target.prototype ? target.prototype : target.__proto__;
            const getParameter = proto.getParameter;
            Object.defineProperty(proto, "getParameter", {
              "value": function () {
                // window.top.postMessage("webgl-fingerprint-defender-alert", '*');
                //
                if (arguments[0] === 3415) return 0;
                else if (arguments[0] === 3414) return 24;
                else if (arguments[0] === 36348) return 30;
                else if (arguments[0] === 7936) return "WebKit";
                else if (arguments[0] === 37445) return "Google Inc. (Google)";
                else if (arguments[0] === 7937) return "WebKit WebGL";
                else if (arguments[0] === 3379) return config.random.number([14, 15]);
                else if (arguments[0] === 36347) return config.random.number([12, 13]);
                else if (arguments[0] === 34076) return config.random.number([14, 15]);
                else if (arguments[0] === 34024) return config.random.number([14, 15]);
                else if (arguments[0] === 3386) return config.random.int([13, 14, 15]);
                else if (arguments[0] === 3413) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 3412) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 3411) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 3410) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 34047) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 34930) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 34921) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 35660) return config.random.number([1, 2, 3, 4]);
                else if (arguments[0] === 35661) return config.random.number([4, 5, 6, 7, 8]);
                else if (arguments[0] === 36349) return config.random.number([10, 11, 12, 13]);
                else if (arguments[0] === 33902) return config.random.float([0, 10, 11, 12, 13]);
                else if (arguments[0] === 33901) return config.random.float([0, 10, 11, 12, 13]);
                else if (arguments[0] === 37446) return config.random.item(["Graphics", "HD Graphics", "Intel(R) HD Graphics"]);
                else if (arguments[0] === 7938) return config.random.item(["WebGL 1.0", "WebGL 1.0 (OpenGL)", "WebGL 1.0 (OpenGL Chromium)"]);
                else if (arguments[0] === 35724) return config.random.item(["WebGL", "WebGL GLSL", "WebGL GLSL ES", "WebGL GLSL ES (OpenGL Chromium"]);
                //
                return getParameter.apply(this, arguments);
              }
            });
          }
        }
      }
    };
    //
    config.spoof.webgl.buffer(WebGLRenderingContext);
    config.spoof.webgl.buffer(WebGL2RenderingContext);
    config.spoof.webgl.parameter(WebGLRenderingContext);
    config.spoof.webgl.parameter(WebGL2RenderingContext);
    //
  };  
  inject()
}
function changeMime(){
    var inject = function () {
      window.navigator.__defineGetter__("platform", function () {
        return "Win32";
      });
      window.navigator.__defineGetter__("hardwareConcurrency", function () {
        return 8;
      });
    }
    inject()
}
function changeAudio(){
    var inject = function () {
      const context = {
        "BUFFER": null,
        "getChannelData": function (e) {
          const getChannelData = e.prototype.getChannelData;
          Object.defineProperty(e.prototype, "getChannelData", {
            "value": function () {
              const results_1 = getChannelData.apply(this, arguments);
              if (context.BUFFER !== results_1) {
                context.BUFFER = results_1;
                for (var i = 0; i < results_1.length; i += 100) {
                  let index = Math.floor(Math.random() * i);
                  results_1[index] = results_1[index] + Math.random() * 0.0000001;
                }
              }
              //
              return results_1;
            }
          });
        },
        "createAnalyser": function (e) {
          const createAnalyser = e.prototype.__proto__.createAnalyser;
          Object.defineProperty(e.prototype.__proto__, "createAnalyser", {
            "value": function () {
              const results_2 = createAnalyser.apply(this, arguments);
              const getFloatFrequencyData = results_2.__proto__.getFloatFrequencyData;
              Object.defineProperty(results_2.__proto__, "getFloatFrequencyData", {
                "value": function () {
                  const results_3 = getFloatFrequencyData.apply(this, arguments);
                  for (var i = 0; i < arguments[0].length; i += 100) {
                    let index = Math.floor(Math.random() * i);
                    arguments[0][index] = arguments[0][index] + Math.random() * 0.1;
                  }
                  //
                  return results_3;
                }
              });
              //
              return results_2;
            }
          });
        }
      };
      //
      context.getChannelData(AudioBuffer);
      context.createAnalyser(AudioContext);
      context.getChannelData(OfflineAudioContext);
      context.createAnalyser(OfflineAudioContext);
      //
    //   document.documentElement.dataset.acxscriptallow = true;
    };
    inject()
}
function changeFont(){
    var inject = function () {
      var rand = {
        "noise": function () {
          var SIGN = Math.random() < Math.random() ? -1 : 1;
          return Math.floor(Math.random() + SIGN * Math.random());
        },
        "sign": function () {
          const tmp = [-1, -1, -1, -1, -1, -1, +1, -1, -1, -1];
          const index = Math.floor(Math.random() * tmp.length);
          return tmp[index];
        }
      };
      //
      Object.defineProperty(HTMLElement.prototype, "offsetHeight", {
        get () {
          const height = Math.floor(this.getBoundingClientRect().height);
          const valid = height && rand.sign() === 1;
          const result = valid ? height + rand.noise() : height;
          return result;
        }
      });
      //
      Object.defineProperty(HTMLElement.prototype, "offsetWidth", {
        get () {
          const width = Math.floor(this.getBoundingClientRect().width);
          const valid = width && rand.sign() === 1;
          const result = valid ? width + rand.noise() : width;
          return result;
        }
      });
    };
    inject()
}

function changeRect(){
  const l=1+Math.random()
  Object.defineProperty(DOMRect.prototype, "height", {
    get() {
        return this.toJSON()["height"]*l;
    },
  });
  Object.defineProperty(DOMRect.prototype, "width", {
    get() {
        return this.toJSON()["width"]*l;
    },
  });
}
function changAllVert() {
  var inject = function () {
    // Object.defineProperty(navigator, 'languages', {
    //     get: function () {
    //         return ['zh-CN',"zh"]
    //     },
    // });
    Object.defineProperty(navigator, 'language', {
        get: function () {
            return 'zh-CN'
        },
    });
    //关闭rtc
    Object.defineProperty(window, "RTCPeerConnection",{
      "get":undefined,
    });
    Object.defineProperty(window, "mozRTCPeerConnection",{
        "get":undefined,
    });
    Object.defineProperty(window, "webkitRTCPeerConnection",{
        "get":undefined,
    });
  
    //模拟插件
    function newPlugin(name,description,filename,htype,suffixes) {
      let mintype=newObject(MimeType,{
        "description":description,
        "suffixes": suffixes,
        "type": htype,
      })
      Object.defineProperty(mintype, 'enabledPlugin', {
        get: () =>mintype
      });
      let plugin={
        0:mintype,
        "description": description,
        "filename": filename,
        "length": 1,
        "name": name,
      }
      plugin[htype]=mintype
      return newObject(Plugin,plugin)      
    }
    let plugins=[
      newPlugin("PDF Viewer","Portable Document Format","internal-pdf-viewer","application/pdf","pdf"),
      newPlugin("Chrome PDF Viewer","Portable Document Format","internal-pdf-viewer","text/pdf","pdf"),
      newPlugin("Chromium PDF Viewer","Portable Document Format","internal-pdf-viewer","text/pdf","pdf"),
      newPlugin("Microsoft Edge PDF Viewer","Portable Document Format","internal-pdf-viewer","text/pdf","pdf"),
      newPlugin("WebKit built-in PDF","Portable Document Format","internal-pdf-viewer","text/pdf","pdf"),
      newPlugin("test"+Math.random(),"Portable Document Format","internal-pdf-viewer","text/pdf","pdf"),
    ]
    plugins=shuffle(plugins)
    let pluginsData ={}
    for(let i=0;i<plugins.length;i++){
      pluginsData[plugins[i].name]=plugins[i]
      pluginsData["length"]=i+1
    }
    Object.defineProperty(navigator, 'plugins', {
      get:()=>newObject(PluginArray,pluginsData),
    });
    for(let i=0;i<plugins.length;i++){
      navigator.plugins.__proto__[i]=plugins[i]
    }
    //模拟插件结束
    // in case of broken image return random height/width
    var size = 0;
    ['height', 'width'].forEach(property => {
        const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property);
        Object.defineProperty(HTMLImageElement.prototype, property, {
            imageDescriptor,
            get: function () {
                if (this.complete && this.naturalHeight == 0) {
                    if (!size) {
                        size = Math.floor(Math.random() * 21) + 10;
                    }
                    return size;
                }
                return imageDescriptor.apply(this);
            },
        });
    }); 
    // hairline feature (headless can't render it normally)
    const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight');
    Object.defineProperty(HTMLElement.prototype, 'offsetHeight', {
        ...imageDescriptor,
        get: function () {
            if (this.id == 'modernizr') {
                return 1;
            }
            return imageDescriptor.apply(this);
        },
    });
  } 
  inject()
}
changAllVert()
changeCanvasMain()
changeWebGlMain()
changeMime()
changeAudio()
changeFont()
changeRect()
  
  

  
  
  
  